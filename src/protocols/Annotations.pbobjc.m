// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: annotations.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "Annotations.pbobjc.h"
#import "google/protobuf/Timestamp.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - AnnotationsRoot

@implementation AnnotationsRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[GPBTimestampRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - AnnotationsRoot_FileDescriptor

static GPBFileDescriptor *AnnotationsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Session

@implementation Session

@dynamic version;
@dynamic clientId;
@dynamic canvasObjectsArray, canvasObjectsArray_Count;

typedef struct Session__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSString *clientId;
  NSMutableArray *canvasObjectsArray;
} Session__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .number = Session_FieldNumber_Version,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(Session__storage_, version),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "clientId",
        .number = Session_FieldNumber_ClientId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Session__storage_, clientId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "canvasObjectsArray",
        .number = Session_FieldNumber_CanvasObjectsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Session__storage_, canvasObjectsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002\010\000\003\000canvasObjects\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Session class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Session__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CanvasObject

@implementation CanvasObject

@dynamic dataOneOfCase;
@dynamic type;
@dynamic id_p;
@dynamic active;
@dynamic shared;
@dynamic page;
@dynamic hasPosition, position;
@dynamic layer;
@dynamic hasCreatedTimeStamp, createdTimeStamp;
@dynamic hasUpdatedTimeStamp, updatedTimeStamp;
@dynamic hasPublishedTimeStamp, publishedTimeStamp;
@dynamic stroke;
@dynamic comment;
@dynamic textOnPage;
@dynamic voiceNote;

typedef struct CanvasObject__storage_ {
  uint32_t _has_storage_[2];
  BOOL active;
  BOOL shared;
  CanvasObject_CanvasType type;
  int32_t page;
  int32_t layer;
  Point_Class *position;
  GPBTimestamp *createdTimeStamp;
  GPBTimestamp *updatedTimeStamp;
  GPBTimestamp *publishedTimeStamp;
  CanvasObject_Stroke *stroke;
  CanvasObject_Comment *comment;
  CanvasObject_Text *textOnPage;
  CanvasObject_VoiceNote *voiceNote;
  int64_t id_p;
} CanvasObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "data",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .number = CanvasObject_FieldNumber_Type,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CanvasObject__storage_, type),
        .defaultValue.valueEnum = CanvasObject_CanvasType_None,
        .dataTypeSpecific.enumDescFunc = CanvasObject_CanvasType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "id_p",
        .number = CanvasObject_FieldNumber_Id_p,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CanvasObject__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "active",
        .number = CanvasObject_FieldNumber_Active,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CanvasObject__storage_, active),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "shared",
        .number = CanvasObject_FieldNumber_Shared,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CanvasObject__storage_, shared),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "page",
        .number = CanvasObject_FieldNumber_Page,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(CanvasObject__storage_, page),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "position",
        .number = CanvasObject_FieldNumber_Position,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, position),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Point_Class),
        .fieldOptions = NULL,
      },
      {
        .name = "layer",
        .number = CanvasObject_FieldNumber_Layer,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(CanvasObject__storage_, layer),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "createdTimeStamp",
        .number = CanvasObject_FieldNumber_CreatedTimeStamp,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, createdTimeStamp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .fieldOptions = NULL,
      },
      {
        .name = "updatedTimeStamp",
        .number = CanvasObject_FieldNumber_UpdatedTimeStamp,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, updatedTimeStamp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .fieldOptions = NULL,
      },
      {
        .name = "publishedTimeStamp",
        .number = CanvasObject_FieldNumber_PublishedTimeStamp,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, publishedTimeStamp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .fieldOptions = NULL,
      },
      {
        .name = "stroke",
        .number = CanvasObject_FieldNumber_Stroke,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, stroke),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_Stroke),
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = CanvasObject_FieldNumber_Comment,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, comment),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_Comment),
        .fieldOptions = NULL,
      },
      {
        .name = "textOnPage",
        .number = CanvasObject_FieldNumber_TextOnPage,
        .hasIndex = -1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, textOnPage),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_Text),
        .fieldOptions = NULL,
      },
      {
        .name = "voiceNote",
        .number = CanvasObject_FieldNumber_VoiceNote,
        .hasIndex = -1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject__storage_, voiceNote),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_VoiceNote),
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = CanvasObject_CanvasType_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\005\010\020\000\t\020\000\n\022\000\r\n\000\016\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CanvasObject_Type_RawValue(CanvasObject *message) {
  GPBDescriptor *descriptor = [CanvasObject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCanvasObject_Type_RawValue(CanvasObject *message, int32_t value) {
  GPBDescriptor *descriptor = [CanvasObject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void CanvasObject_ClearDataOneOfCase(CanvasObject *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - Enum CanvasObject_CanvasType

GPBEnumDescriptor *CanvasObject_CanvasType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "None", .number = CanvasObject_CanvasType_None },
      { .name = "Ink", .number = CanvasObject_CanvasType_Ink },
      { .name = "Comment", .number = CanvasObject_CanvasType_Comment },
      { .name = "TextOnPage", .number = CanvasObject_CanvasType_TextOnPage },
      { .name = "VoiceNote", .number = CanvasObject_CanvasType_VoiceNote },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CanvasObject_CanvasType)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CanvasObject_CanvasType_IsValidValue];
  }
  return descriptor;
}

BOOL CanvasObject_CanvasType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CanvasObject_CanvasType_None:
    case CanvasObject_CanvasType_Ink:
    case CanvasObject_CanvasType_Comment:
    case CanvasObject_CanvasType_TextOnPage:
    case CanvasObject_CanvasType_VoiceNote:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CanvasObject_Stroke

@implementation CanvasObject_Stroke

@dynamic hasPen, pen;
@dynamic pathArray, pathArray_Count;

typedef struct CanvasObject_Stroke__storage_ {
  uint32_t _has_storage_[1];
  CanvasObject_Stroke_Pen *pen;
  NSMutableArray *pathArray;
} CanvasObject_Stroke__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pen",
        .number = CanvasObject_Stroke_FieldNumber_Pen,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke__storage_, pen),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_Stroke_Pen),
        .fieldOptions = NULL,
      },
      {
        .name = "pathArray",
        .number = CanvasObject_Stroke_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke__storage_, pathArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CanvasObject_Stroke_Path),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_Stroke class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_Stroke__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CanvasObject_Stroke_Pen

@implementation CanvasObject_Stroke_Pen

@dynamic mask;
@dynamic hasRgbColor, rgbColor;
@dynamic thickness;

typedef struct CanvasObject_Stroke_Pen__storage_ {
  uint32_t _has_storage_[1];
  CanvasObject_Stroke_Pen_Mask mask;
  float thickness;
  RGBColor *rgbColor;
} CanvasObject_Stroke_Pen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mask",
        .number = CanvasObject_Stroke_Pen_FieldNumber_Mask,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CanvasObject_Stroke_Pen__storage_, mask),
        .defaultValue.valueEnum = CanvasObject_Stroke_Pen_Mask_None,
        .dataTypeSpecific.enumDescFunc = CanvasObject_Stroke_Pen_Mask_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "rgbColor",
        .number = CanvasObject_Stroke_Pen_FieldNumber_RgbColor,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke_Pen__storage_, rgbColor),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(RGBColor),
        .fieldOptions = NULL,
      },
      {
        .name = "thickness",
        .number = CanvasObject_Stroke_Pen_FieldNumber_Thickness,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(CanvasObject_Stroke_Pen__storage_, thickness),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = CanvasObject_Stroke_Pen_Mask_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\010\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_Stroke_Pen class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_Stroke_Pen__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CanvasObject_Stroke_Pen_Mask_RawValue(CanvasObject_Stroke_Pen *message) {
  GPBDescriptor *descriptor = [CanvasObject_Stroke_Pen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_Stroke_Pen_FieldNumber_Mask];
  return GPBGetMessageInt32Field(message, field);
}

void SetCanvasObject_Stroke_Pen_Mask_RawValue(CanvasObject_Stroke_Pen *message, int32_t value) {
  GPBDescriptor *descriptor = [CanvasObject_Stroke_Pen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_Stroke_Pen_FieldNumber_Mask];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CanvasObject_Stroke_Pen_Mask

GPBEnumDescriptor *CanvasObject_Stroke_Pen_Mask_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "None", .number = CanvasObject_Stroke_Pen_Mask_None },
      { .name = "Eraser", .number = CanvasObject_Stroke_Pen_Mask_Eraser },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CanvasObject_Stroke_Pen_Mask)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CanvasObject_Stroke_Pen_Mask_IsValidValue];
  }
  return descriptor;
}

BOOL CanvasObject_Stroke_Pen_Mask_IsValidValue(int32_t value__) {
  switch (value__) {
    case CanvasObject_Stroke_Pen_Mask_None:
    case CanvasObject_Stroke_Pen_Mask_Eraser:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CanvasObject_Stroke_Path

@implementation CanvasObject_Stroke_Path

@dynamic curveType;
@dynamic hasPoint1, point1;
@dynamic hasPoint2, point2;
@dynamic hasPoint3, point3;

typedef struct CanvasObject_Stroke_Path__storage_ {
  uint32_t _has_storage_[1];
  int32_t curveType;
  Point_Class *point1;
  Point_Class *point2;
  Point_Class *point3;
} CanvasObject_Stroke_Path__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "curveType",
        .number = CanvasObject_Stroke_Path_FieldNumber_CurveType,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(CanvasObject_Stroke_Path__storage_, curveType),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "point1",
        .number = CanvasObject_Stroke_Path_FieldNumber_Point1,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke_Path__storage_, point1),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Point_Class),
        .fieldOptions = NULL,
      },
      {
        .name = "point2",
        .number = CanvasObject_Stroke_Path_FieldNumber_Point2,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke_Path__storage_, point2),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Point_Class),
        .fieldOptions = NULL,
      },
      {
        .name = "point3",
        .number = CanvasObject_Stroke_Path_FieldNumber_Point3,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Stroke_Path__storage_, point3),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Point_Class),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_Stroke_Path class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_Stroke_Path__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CanvasObject_Comment

@implementation CanvasObject_Comment

@dynamic comment;

typedef struct CanvasObject_Comment__storage_ {
  uint32_t _has_storage_[1];
  NSString *comment;
} CanvasObject_Comment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "comment",
        .number = CanvasObject_Comment_FieldNumber_Comment,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CanvasObject_Comment__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_Comment class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_Comment__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CanvasObject_Text

@implementation CanvasObject_Text

@dynamic hasDimensions, dimensions;
@dynamic fontSize;
@dynamic textAlignment;
@dynamic hasTextColor, textColor;
@dynamic text;

typedef struct CanvasObject_Text__storage_ {
  uint32_t _has_storage_[1];
  float fontSize;
  CanvasObject_Text_TextAlignment textAlignment;
  Dimensions *dimensions;
  RGBColor *textColor;
  NSString *text;
} CanvasObject_Text__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dimensions",
        .number = CanvasObject_Text_FieldNumber_Dimensions,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Text__storage_, dimensions),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Dimensions),
        .fieldOptions = NULL,
      },
      {
        .name = "fontSize",
        .number = CanvasObject_Text_FieldNumber_FontSize,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(CanvasObject_Text__storage_, fontSize),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "textAlignment",
        .number = CanvasObject_Text_FieldNumber_TextAlignment,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CanvasObject_Text__storage_, textAlignment),
        .defaultValue.valueEnum = CanvasObject_Text_TextAlignment_Left,
        .dataTypeSpecific.enumDescFunc = CanvasObject_Text_TextAlignment_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "textColor",
        .number = CanvasObject_Text_FieldNumber_TextColor,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CanvasObject_Text__storage_, textColor),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(RGBColor),
        .fieldOptions = NULL,
      },
      {
        .name = "text",
        .number = CanvasObject_Text_FieldNumber_Text,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CanvasObject_Text__storage_, text),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = CanvasObject_Text_TextAlignment_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\002\010\000\003\r\000\004\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_Text class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_Text__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CanvasObject_Text_TextAlignment_RawValue(CanvasObject_Text *message) {
  GPBDescriptor *descriptor = [CanvasObject_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_Text_FieldNumber_TextAlignment];
  return GPBGetMessageInt32Field(message, field);
}

void SetCanvasObject_Text_TextAlignment_RawValue(CanvasObject_Text *message, int32_t value) {
  GPBDescriptor *descriptor = [CanvasObject_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CanvasObject_Text_FieldNumber_TextAlignment];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CanvasObject_Text_TextAlignment

GPBEnumDescriptor *CanvasObject_Text_TextAlignment_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Left", .number = CanvasObject_Text_TextAlignment_Left },
      { .name = "Center", .number = CanvasObject_Text_TextAlignment_Center },
      { .name = "Right", .number = CanvasObject_Text_TextAlignment_Right },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CanvasObject_Text_TextAlignment)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CanvasObject_Text_TextAlignment_IsValidValue];
  }
  return descriptor;
}

BOOL CanvasObject_Text_TextAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case CanvasObject_Text_TextAlignment_Left:
    case CanvasObject_Text_TextAlignment_Center:
    case CanvasObject_Text_TextAlignment_Right:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CanvasObject_VoiceNote

@implementation CanvasObject_VoiceNote

@dynamic audioAttachmentId;

typedef struct CanvasObject_VoiceNote__storage_ {
  uint32_t _has_storage_[1];
  NSString *audioAttachmentId;
} CanvasObject_VoiceNote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioAttachmentId",
        .number = CanvasObject_VoiceNote_FieldNumber_AudioAttachmentId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CanvasObject_VoiceNote__storage_, audioAttachmentId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\021\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CanvasObject_VoiceNote class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CanvasObject_VoiceNote__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RGBColor

@implementation RGBColor

@dynamic red;
@dynamic green;
@dynamic blue;

typedef struct RGBColor__storage_ {
  uint32_t _has_storage_[1];
  int32_t red;
  int32_t green;
  int32_t blue;
} RGBColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "red",
        .number = RGBColor_FieldNumber_Red,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(RGBColor__storage_, red),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "green",
        .number = RGBColor_FieldNumber_Green,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(RGBColor__storage_, green),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "blue",
        .number = RGBColor_FieldNumber_Blue,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(RGBColor__storage_, blue),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RGBColor class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RGBColor__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Point_Class

@implementation Point_Class

@dynamic x;
@dynamic y;

typedef struct Point_Class__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
} Point_Class__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .number = Point_Class_FieldNumber_X,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(Point_Class__storage_, x),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "y",
        .number = Point_Class_FieldNumber_Y,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(Point_Class__storage_, y),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Point_Class class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Point_Class__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Dimensions

@implementation Dimensions

@dynamic width;
@dynamic height;

typedef struct Dimensions__storage_ {
  uint32_t _has_storage_[1];
  float width;
  float height;
} Dimensions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .number = Dimensions_FieldNumber_Width,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(Dimensions__storage_, width),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "height",
        .number = Dimensions_FieldNumber_Height,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(Dimensions__storage_, height),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Dimensions class]
                                     rootClass:[AnnotationsRoot class]
                                          file:AnnotationsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Dimensions__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
